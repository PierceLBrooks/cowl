# How-to {#howto}

@tableofcontents

## Building from source {#howto-building}

Cowl can be built and run on **Windows**, **macOS** and **Linux**. We have successfully
deployed it to a wider range of platforms, including very tiny microcontrollers,
with relatively minor build system setup. It can be compiled via any fairly recent version
of either **GCC**, **LLVM** or **MSVC**, both as a **static** and **dynamic library**.

### Requirements {#howto-building-requirements}

In order to compile it, you will need:

- [CMake](https://cmake.org) version 3.0 or later.
- [Flex](https://github.com/westes/flex) version 2.6 or later.
- [Bison](https://www.gnu.org/software/bison) version 3.0 or later.

### Downloading the sources {#howto-building-download}

You can find Cowl's code on its [git repository](https://github.com/sisinflab-swot/cowl).
Please note that it contains submodules, so it's recommended that you clone it using the
`--recursive` flag.

```
git clone --recursive https://github.com/sisinflab-swot/cowl.git
```

### Compiling {#howto-building-compiling}

The following commands allow you to build Cowl
via [UNIX makefiles](https://www.gnu.org/software/make) generated by CMake:

```
# Create a suitable build dir.
mkdir cmake-build-release && cd cmake-build-release

# Generate the makefile.
cmake ../

# Build the libraries and install their public headers into the output dir.
make install
```

## Programming with Cowl {#howto-programming}

The easiest way to get started is by checking out the provided [examples](@ref howto-examples).
However, in order to understand the principles behind the API, reading
this section carefully is strongly recommended.

### API initialization {#howto-init}

Before making any API call, you **must** invoke `cowl_api_init()`. Since C doesn't have
static initializers, requiring the programmer to call an explicit initialization function
is the only portable way to setup static members which cannot be lazily initialized.
Calling API members without initializing the API is undefined behavior.

### Ontology deserialization {#howto-parsing}

In order to query an ontology you must first deserialize it. This can be done via the
`cowl_parser_parse_ontology()` function of `CowlParser`. In general, ontologies may
[import](https://www.w3.org/TR/owl2-syntax/#Imports) other ontologies. Since networking
is not part of the C standard library, and one of the key principles of Cowl is portability,
ontology retrieval is delegated to the end user via the `CowlImportsLoader` interface.

### Ontology queries {#howto-querying}

The core type of the API is `CowlOntology`, which consists of a set of `CowlAxiom`
instances. The base mechanism for querying a `CowlOntology` is invoking its iterator
member functions, which generally accept `CowlIterator` instances.

`CowlIterator` is a wrapper around a function that gets called for every element matched
by the query. By providing a generic context pointer, you can plug any custom data structure
(loggers, collections, etc.) thus allowing for arbitrarily complex queries.

The iterator function returns a `boolean` that can be used to control iteration:
by returning `true` iteration goes on to the next element, while returning `false`
causes it to stop. This is useful if, for example, you want to find the first element
matching certain criteria.

### Memory management {#howto-memory}

Cowl uses [reference counting](https://en.wikipedia.org/wiki/Reference_counting)
for memory management. You increase and decrease the reference count via `retain` and `release`
member functions available for every data structure. The API docs are very explicit
about which functions return already retained instances, which you must release. If nothing is
specified, then the returned instance is not retained, meaning its lifetime is generally
tied to its parent instance. If you need to keep it alive even after its parent has been
deallocated, you must `retain` it.

### Pseudo-inheritance {#howto-inheritance}

Since the [OWL 2 specification](https://www.w3.org/TR/owl2-syntax) is highly hierarchical,
the API makes extensive use of pseudo-inheritance for structs. This means you can, for example,
cast a `CowlClass` to `CowlClsExp` and back. Of course, if the API returns a base pseudo-class
such as `CowlClsExp`, and you're unsure about the concrete subclass, you can check
its type via `get_type` functions and cast accordingly.
The API docs for type enumerations explicitly state the concrete struct associated with every type.

## Examples {#howto-examples}

Check out the [examples](@ref examples) page.
